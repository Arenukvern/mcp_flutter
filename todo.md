Okay, here is the exact step-by-step plan for implementing the YAML-driven code generation for your Flutter RPC handlers, formatted for an AI agent to follow:

**Step-by-Step Plan for YAML-Driven Flutter RPC Handler Generation**

1.  **Create `server_tools_handler.yaml` File:**

    - Create a new file named `server_tools_handler.yaml` in the root directory of your project.
    - Populate this file with the following YAML structure based from `flutter_rpc.ts` and `flutter_inspector_server.ts`. This structure defines the tool handlers and their configurations.
    - rpcMethod is combined string with the rpcPrefix to form the full rpc method name. Please ensure this is correct and be extremely careful. the final rpce call should look like: ext.flutter.inspector.getProperties

    ```yaml
    # server_tools_handler.yaml
    handlers:
      - name: get_widget_tree
        description: Fetches the widget tree.
        rpcMethod: "debug.dumpRenderTree"
        needsDebugVerification: true
        responseWrapper: true
        parameters: {}

      - name: get_widget_details
        description: Fetches details for a specific widget.
        rpcMethod: "inspector.getProperties"
        needsDebugVerification: true
        responseWrapper: true
        parameters:
          objectId: "arg.objectId"

      - name: toggle_debug_paint
        description: Toggles debug paint mode.
        rpcMethod: "debug.setDebugPaint"
        needsDebugVerification: true
        responseWrapper: true
        parameters:
          enabled: ""

      - name: get_extension_rpcs
        description: Gets the list of extension RPCs.
        rpcMethod: "get_extension_rpcs"
        needsDebugVerification: false
        responseWrapper: true
        parameters:
          isolateId: ""
          isRawResponse: ""

      # Add more tool handler definitions here following the same structure.
    ```

    - **Note:** You can add more handler definitions under the `handlers` array, following the same structure as the examples provided. Ensure correct YAML syntax (indentation, etc.).

2.  **Create Code Generation Script `generate_rpc_handlers.ts`:**

    - Create a new directory named `scripts` in the root of your project if it doesn't exist.
    - Inside the `scripts` directory, create a new TypeScript file named `generate_rpc_handlers.ts`.
    - Paste the following TypeScript code into `generate_rpc_handlers.ts`. This script reads `server_tools_handler.yaml` and generates the `FlutterRpcHandlers` class in `src/servers/flutter_rpc_handlers.generated.ts`.

    ```typescript
    // scripts/generate_rpc_handlers.ts
    import fs from "fs";
    import yaml from "js-yaml";
    import path from "path";

    async function generateRpcHandlers() {
      const yamlFilePath = path.resolve(
        __dirname,
        "..",
        "server_tools_handler.yaml"
      );
      const generatedFilePath = path.resolve(
        __dirname,
        "..",
        "src",
        "servers",
        "flutter_rpc_handlers.generated.ts"
      );

      try {
        const yamlContent = fs.readFileSync(yamlFilePath, "utf8");
        const handlerConfig = yaml.load(yamlContent) as { handlers: any[] };

        let generatedCode = `
        import { FlutterInspectorServer } from "./flutter_inspector_server";
    
        /**
         * Generated class containing handlers for Flutter RPC tools.
         *
         * This class is generated from server_tools_handler.yaml.
         * Do not edit this file directly.
         */
        export class FlutterRpcHandlers {
          private server: FlutterInspectorServer;
    
          constructor(server: FlutterInspectorServer) {
            this.server = server;
          }
        `;

        for (const handler of handlerConfig.handlers) {
          const methodName = `handle${handler.name
            .split("_")
            .map((part: string) => part.charAt(0).toUpperCase() + part.slice(1))
            .join("")}`;
          const description = handler.description.replace(/\n/g, "\n   * "); // Format description for JSDoc
          const rpcMethod = handler.rpcMethod;
          const needsDebugVerification =
            handler.needsDebugVerification === true;
          const responseWrapper = handler.responseWrapper !== false; // Default to true if not explicitly false
          const parameters = handler.parameters || {};

          let paramsExtraction = "";
          let rpcParamsObject: string = "{}";

          if (Object.keys(parameters).length > 0) {
            rpcParamsObject = "{ ";
            for (const [paramName, paramMapping] of Object.entries(
              parameters
            )) {
              if (paramMapping === "") {
                rpcParamsObject += `${paramName}: params?.${paramName}, `;
              } else if (paramMapping === "port") {
                rpcParamsObject += `${paramName}: port, `;
              } else if (paramMapping.startsWith("arg.")) {
                const rpcParamName = paramMapping.substring(4); // Remove "arg." prefix
                rpcParamsObject += `arg: { ...arg, ${rpcParamName}: params?.${paramName} }, `;
              }
            }
            rpcParamsObject = rpcParamsObject.slice(0, -2) + " }"; // Remove trailing comma and space
          }

          generatedCode += `
          /**
           * ${description}
           */
          private async ${methodName}(port: number, params: any): Promise<unknown> {
            ${
              needsDebugVerification
                ? "await this.server.verifyFlutterDebugMode(port);"
                : ""
            }
            const result = await this.server.invokeFlutterExtension(port, "${rpcMethod}", ${rpcParamsObject.trim()});
            ${
              responseWrapper
                ? "return this.server.wrapResponse(Promise.resolve(result));"
                : "return result;"
            }
          }
          `;
        }

        generatedCode += `
        }
        `;

        fs.writeFileSync(generatedFilePath, generatedCode.trim() + "\n");
        console.log(
          `Generated FlutterRpcHandlers class at: ${generatedFilePath}`
        );
      } catch (error) {
        console.error("Error generating FlutterRpcHandlers:", error);
      }
    }

    generateRpcHandlers();
    ```

3.  **Update `tsconfig.json`:**

    - Open your `tsconfig.json` file in the project root.
    - Ensure that the `scripts` directory is excluded from compilation. Add or modify the `exclude` section to include `"scripts"`:

    ```json
    // tsconfig.json
    {
      "compilerOptions": {
        // ... your compiler options ...
      },
      "include": [
        "src" // Or your source code directories
      ],
      "exclude": [
        "node_modules",
        "scripts", // Exclude the scripts directory
        "**/*.test.ts",
        "**/*.spec.ts"
      ]
    }
    ```

4.  **Update `package.json`:**

    - Open your `package.json` file in the project root.
    - Modify the `scripts` section to include a script to run the code generation and integrate it into your build process.

    ```json
    // package.json
    {
      "scripts": {
        "generate-rpc-handlers": "ts-node scripts/generate_rpc_handlers.ts",
        "build": "npm run generate-rpc-handlers && tsc",
        "start": "node dist/index.js" // Or your start script
        // ... other scripts ...
      },
      "devDependencies": {
        "js-yaml": "^4.1.0", // Ensure js-yaml is listed as a dev dependency
        "ts-node": "^10.9.1" // Ensure ts-node is listed as a dev dependency
        // ... other dev dependencies ...
      },
      "dependencies": {
        // ... your dependencies ...
      }
    }
    ```

    - **Ensure `js-yaml` and `ts-node` are in `devDependencies`:** If you don't have them already, install them by running: `npm install --save-dev js-yaml ts-node`.

5.  **Modify `FlutterInspectorServer` (`src/servers/flutter_inspector_server.ts`):**

    - Open `src/servers/flutter_inspector_server.ts`.
    - **Import `FlutterRpcHandlers`:** Add the following import at the top of the file:

      ```typescript
      import { FlutterRpcHandlers } from "./flutter_rpc_handlers.generated";
      ```

    - **Update `createRpcHandlerMap` method:** Replace the existing `createRpcHandlerMap` method with the following:

      ```typescript
      private createRpcHandlerMap(rpcHandlers: FlutterRpcHandlers): Record<string, any> {
        return {
          "get_widget_tree": (request: any) => {
            const port = this.handlePortParam(request);
            return rpcHandlers.handleGetWidgetTree(port);
          },
          "get_widget_details": (request: any) => {
            const port = this.handlePortParam(request);
            const params = request.params.arguments;
            return rpcHandlers.handleGetWidgetDetails(port, params);
          },
          "toggle_debug_paint": (request: any) => {
            const port = this.handlePortParam(request);
            const params = request.params.arguments;
            return rpcHandlers.handleToggleDebugPaint(port, params);
          },
          "get_extension_rpcs": (request: any) => {
            const port = this.handlePortParam(request);
            const params = request.params.arguments;
            return rpcHandlers.handleGetExtensionRpcs(port, params);
          },
          // ... add entries for all handlers defined in server_tools_handler.yaml ...
        };
      }
      ```

      - **Important:** Ensure you add entries in this map for _all_ handlers defined in your `server_tools_handler.yaml`. The keys should match the `name` property in your YAML definitions.

    - **Update `setupToolHandlers` method:** Modify the `setupToolHandlers` method to use the generated `FlutterRpcHandlers` and the handler map.

      ```typescript
      private setupToolHandlers() {
        // Default port for Flutter/Dart processes
        const DEFAULT_FLUTTER_PORT = 8181;
        const serverToolsPath = path.join(__dirname, "server_tools.yaml");
        const serverToolsContent = fs.readFileSync(serverToolsPath, "utf8");
        const serverTools = yaml.load(serverToolsContent) as { tools: any[] };

        this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
          tools: serverTools.tools,
        }));

        const rpcHandlers = new FlutterRpcHandlers(this); // Instantiate FlutterRpcHandlers
        const handlerMap = this.createRpcHandlerMap(rpcHandlers); // Create handler map

        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
          const toolName = request.params.name;
          const handler = handlerMap[toolName];
          if (handler) {
            return handler(request);
          } else {
            // Fallback to original switch for non-generated tools if needed, or handle error
            // For now, throwing error for unknown tools.
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${toolName}`
            );
          }
        });
      }
      ```

      - **Remove or Comment Out Old `switch` Cases:** Remove or comment out the `case` blocks within the `switch` statement in `setupToolHandlers` that correspond to the handlers you've moved to `server_tools_handler.yaml` and are now generated. You should only keep the cases for tools that are _not_ generated (like `get_active_ports` and `get_supported_protocols` in your original code).

6.  **Run Code Generation and Build:**

    - Execute the build script from your terminal: `npm run build`
    - This will first run the `generate-rpc-handlers` script, which will generate `src/servers/flutter_rpc_handlers.generated.ts`.
    - Then, it will compile your TypeScript project, including the generated file, into the `dist` directory.

7.  **Test Your Server:**
    - Run your server using `npm start` (or your usual start command).
    - Thoroughly test all the tool handlers that are now generated from `server_tools_handler.yaml`. Ensure they function as expected. Check for correct parameter passing, debug mode verification, and response wrapping.

After completing these steps, your Flutter Inspector Server will be using the YAML-driven code generation for Flutter RPC handlers. If you encounter any issues during these steps, please provide specific error messages or unexpected behavior, and I will assist you further.
