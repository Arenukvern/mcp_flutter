# todo_proxy.yaml: Plan for Setting Up and Integrating the Dart Proxy Server

# Overview:
# This document outlines the steps to create, configure, and integrate a Dart proxy server
# for interacting with the Flutter VM Service, specifically for retrieving widget tree
# information in a robust and maintainable way.  This plan uses the 'ext.flutter.inspector'
# service extension methods for programmatic access, ensuring compatibility and proper
# memory management.  It leverages the 'devtools_app_shared' package for simplified
# VM Service interaction.

# Phase 1: Dart Proxy Server Setup

- name: Create Dart Project
  description: Create a new, pure Dart project (not a Flutter project).
  steps:
    - command: dart create -t console-full dart_proxy
      cwd: ./  # Execute in the desired project directory
      expected_output: "Created project dart_proxy"
    - command: cd dart_proxy
      cwd: ./
      expected_output: ""

- name: Add Dependencies
  description: Add necessary packages to pubspec.yaml.
  steps:
    - action: edit_file
      file: pubspec.yaml
      changes:
        - type: add_dependency
          dependency: vm_service
          version: ^13.0.0 # Use latest compatible version
        - type: add_dependency
          dependency: shelf
          version: ^1.4.1 # Or shelf_router
        - type: add_dependency
          dependency: shelf_web_socket
          version: ^1.0.4
        - type: add_dependency
          dependency: web_socket_channel
          version: ^2.4.0
        - type: add_dependency
          dependency: devtools_app_shared
          version: ^3.3.1  # Use latest compatible version
    - command: dart pub get
      cwd: ./dart_proxy
      expected_output: "Resolving dependencies..."

- name: Implement Proxy Logic
  description: Create the main Dart file and implement the proxy logic.
  steps:
    - action: create_file
      file: bin/dart_proxy.dart
      content: |
        import 'dart:async';
        import 'dart:convert';
        import 'dart:io';

        import 'package:devtools_app_shared/service.dart';
        import 'package:devtools_app_shared/utils.dart';
        import 'package:vm_service/vm_service.dart' as vm_service;
        import 'package:vm_service/vm_service_io.dart';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as shelf_io;
        import 'package:shelf_web_socket/shelf_web_socket.dart';
        import 'package:web_socket_channel/web_socket_channel.dart';

        final serviceManager = ServiceManager();

        void main() async {
          final handler = webSocketHandler((WebSocketChannel webSocket) {
            webSocket.stream.listen((message) async {
              try {
                final request = jsonDecode(message);
                final command = request['command'];
                final port = request['port'] ?? 8181;

                await serviceManager.connect(
                  uri: 'ws://localhost:$port/ws',
                  ধরতেVmService: (uri) => vmServiceConnectUri(uri, log: StdOutLogger()),
                );

                if (!serviceManager.hasConnection) {
                  webSocket.sink.add(jsonEncode({'error': 'Not connected to VM Service.'}));
                  return;
                }

                switch (command) {
                  case 'getWidgetTree':
                    final includeProperties = request['includeProperties'] ?? false;
                    final subtreeDepth = request['subtreeDepth'] ?? 1000; // Default depth
                    final widgetTree = await getWidgetTree(
                      serviceManager.service!,
                      includeProperties: includeProperties,
                      subtreeDepth: subtreeDepth,
                    );
                    webSocket.sink.add(jsonEncode({'result': widgetTree}));
                    break;
                  // Add other commands here (e.g., getProperties, setSelection, etc.)
                  default:
                    webSocket.sink.add(jsonEncode({'error': 'Unknown command: $command'}));
                }
              } catch (e) {
                webSocket.sink.add(jsonEncode({'error': 'Error: $e'}));
              }
            });
          });

          final server = await shelf_io.serve(handler, 'localhost', 8888);
          print('Proxy server listening on port ${server.port}');
        }

        Future<Map<String, dynamic>> getWidgetTree(
          vm_service.VmService vmService, {
          bool includeProperties = false,
          int subtreeDepth = 1000,
        }) async {
          final isolateRef = serviceManager.isolateManager.mainIsolate.value;
          if (isolateRef == null) {
            throw Exception('No main isolate found.');
          }
          final isolateId = isolateRef.id!;

          // Check if the widget tree is ready.
          final isWidgetTreeReady = await vmService.callServiceExtension(
            'ext.flutter.inspector.isWidgetTreeReady',
            isolateId: isolateId,
          );

          if (isWidgetTreeReady.json!['result'] != true) {
              throw Exception("Widget tree is not ready");
          }


          // Get the root widget summary tree.
          final summaryTree = await vmService.callServiceExtension(
            'ext.flutter.inspector.getRootWidgetSummaryTree',
            isolateId: isolateId,
          );

          // Convert to a more usable format and recursively fetch details.
          return _processWidgetTree(vmService, isolateId, summaryTree.json!, subtreeDepth, includeProperties, {});
        }

        Future<Map<String, dynamic>> _processWidgetTree(
          vm_service.VmService vmService,
          String isolateId,
          Map<String, dynamic> widgetData,
          int subtreeDepth,
          bool includeProperties,
            Map<String, dynamic> idToJson,
        ) async {
          final String? id = widgetData['id'];
          final String? creationLocation = widgetData['creationLocation'];

          // Fetch properties if requested.
          Map<String, dynamic>? properties;
          if (includeProperties && id != null) {
              idToJson[id] = widgetData;
            try {
              final propertiesResponse = await vmService.callServiceExtension(
                'ext.flutter.inspector.getProperties',
                isolateId: isolateId,
                args: {'objectId': id},
              );
              properties = propertiesResponse.json!;
            } catch (e) {
              print('Error fetching properties for $id: $e');
              properties = {'error': 'Failed to fetch properties'};
            }
          }

          final result = {
            'description': widgetData['description'],
            'type': widgetData['type'],
            'properties': properties, // Include properties
            'creationLocation': creationLocation,
            'children': <Map<String, dynamic>>[],
          };

          if (id != null && subtreeDepth > 0) {
            try {
              // Get detailed children.
              final childrenResponse = await vmService.callServiceExtension(
                'ext.flutter.inspector.getChildrenDetailsSubtree',
                isolateId: isolateId,
                args: {'objectId': id, 'subtreeDepth': subtreeDepth -1},
              );

              final children = childrenResponse.json!['children'] as List<dynamic>?;
              if (children != null) {
                for (final child in children) {
                  result['children'].add(await _processWidgetTree(
                    vmService,
                    isolateId,
                    child,
                    subtreeDepth - 1,
                    includeProperties,
                      idToJson
                  ));
                }
              }
            } catch (e) {
              print('Error fetching children for $id: $e');
              result['children'].add({'error': 'Failed to fetch children'});
            } finally {
                // Always dispose of the ID to prevent memory leaks.
                await vmService.callServiceExtension('ext.flutter.inspector.disposeId',
                    isolateId: isolateId, args: {'id': id});
            }
          }

          return result;
        }

- name: Run Dart Proxy
  description: Start the Dart proxy server.
  steps:
    - command: dart run bin/dart_proxy.dart
      cwd: ./dart_proxy
      expected_output: "Proxy server listening on port 8888"

# Phase 2: MCP Server Modifications (TypeScript)

- name: Update MCP Server Code
  description: Modify the MCP server to communicate with the Dart proxy.
  steps:
    - action: edit_file
      file: src/index.ts # Replace with your actual file path
      changes:
        - type: add_import
          import: WebSocket
          from: ws
        - type: add_property
          class_name: FlutterInspectorServer  # Replace with your class name
          property: dartProxyWs
          type: WebSocket | null
          initial_value: null
        - type: add_property
          class_name: FlutterInspectorServer
          property: proxyPort
          type: number
          initial_value: 8888
        - type: add_property
          class_name: FlutterInspectorServer
          property: pendingProxyRequests
          type: 'Map<string, { resolve: Function; reject: Function }>'
          initial_value: 'new Map()'
        - type: add_method
          class_name: FlutterInspectorServer
          method_name: connectToDartProxy
          return_type: 'Promise<WebSocket>'
          content: |
            private async connectToDartProxy(): Promise<WebSocket> {
              if (this.dartProxyWs && this.dartProxyWs.readyState === WebSocket.OPEN) {
                return this.dartProxyWs;
              }

              return new Promise((resolve, reject) => {
                const wsUrl = `ws://localhost:${this.proxyPort}`;
                const ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                  this.log("debug", `WebSocket connected to Dart proxy at ${wsUrl}`);
                  this.dartProxyWs = ws;
                  resolve(ws);
                };

                ws.onerror = (error) => {
                  this.log("error", `WebSocket error for Dart proxy:`, error);
                  reject(error);
                  this.dartProxyWs = null; // Clear on error
                };

                ws.onclose = () => {
                  this.log("debug", `WebSocket closed for Dart proxy`);
                  this.dartProxyWs = null;
                };

                ws.onmessage = (event) => {
                  try {
                    const response = JSON.parse(event.data.toString());
                    if (response.id) {
                      const request = this.pendingProxyRequests.get(response.id);
                      if (request) {
                        if (response.error) {
                          request.reject(new Error(response.error));
                        } else {
                          request.resolve(response.result);
                        }
                        this.pendingProxyRequests.delete(response.id);
                      }
                    }
                  } catch (error) {
                    this.log("error", "Error parsing Dart proxy message:", error);
                  }
                };
              });
            }
        - type: add_method
          class_name: FlutterInspectorServer
          method_name: sendDartProxyRequest
          return_type: 'Promise<any>'
          content: |
            private async sendDartProxyRequest(command: string, port: number, args: Record<string, any> = {}): Promise<any> {
                const ws = await this.connectToDartProxy();
                const id = this.generateId();

                const request = {
                    id,
                    command,
                    port,
                    ...args,
                };

                return new Promise((resolve, reject) => {
                    this.pendingProxyRequests.set(id, { resolve, reject });
                    ws.send(JSON.stringify(request));
                });
            }
        - type: modify_switch_case
          switch_variable: request.params.name
          case: get_widget_tree_proxy # Add or modify this case
          content: |
            case "get_widget_tree_proxy": {
              const port = handlePortParam();
              const includeProperties = request.params.arguments?.includeProperties as boolean | undefined;
              const subtreeDepth = request.params.arguments?.subtreeDepth as number | undefined;
              return wrapResponse(this.sendDartProxyRequest('getWidgetTree', port, { includeProperties, subtreeDepth }));
            }
        - type: add_tool
          tool_name: get_widget_tree_proxy
          description: "Gets the widget tree via the Dart proxy server."
          input_schema: |
            {
              type: "object",
              properties: {
                port: {
                  type: "number",
                  description: "Port number where the Flutter app is running (defaults to 8181)",
                },
                includeProperties: {
                  type: "boolean",
                  description: "Whether to include widget properties (default: false)",
                },
                subtreeDepth: {
                  type: "number",
                  description: "Maximum depth of the subtree to fetch (default: 1000)",
                },
              },
              required: [],
            }

# Phase 3: Testing and Verification

- name: Run Flutter App in Debug Mode
  description: Ensure the Flutter app is running in debug mode.
  steps:
    - command: flutter run --debug -d chrome # Or your preferred device
      cwd: ./your_flutter_app  # Replace with your Flutter app directory
      expected_output: "Debug service listening on ws://..."

- name: Test from MCP Server
  description: Use Cursor or another client to send requests to the MCP server.
  steps:
    - action: send_mcp_request
      tool: get_widget_tree_proxy
      arguments:
        port: 8181  # Or the port your Flutter app is using
        includeProperties: true # Optional
        subtreeDepth: 5 # Optional
      expected_output: "A JSON representation of the widget tree"

- name: Verify Output
  description: Check that the output is a structured JSON object representing the widget tree.
  steps:
    - action: verify_json_structure
      expected_structure:
        - description: string
        - type: string
        - properties: object | null
        - children: array

# Phase 4: Refinements and Extensions (Optional)

- name: Add More Commands
  description: Extend the Dart proxy to handle other inspector commands.
  steps:
    - action: modify_dart_code
      file: bin/dart_proxy.dart
      changes:
        - type: add_case
          switch_variable: command
          case: getProperties # Example: Add a case for getProperties
          content: |
            case 'getProperties':
              // ... Implement logic to fetch properties ...
              break;
    - action: modify_typescript_code
      file: src/index.ts
      changes:
        - type: add_tool # Add corresponding tool in MCP server
          tool_name: get_properties_proxy
          # ... tool definition ...
        - type: modify_switch_case
          switch_variable: request.params.name
          case: get_properties_proxy
          content: |
            case "get_properties_proxy": {
              // ... Call sendDartProxyRequest with appropriate arguments ...
            }

- name: Implement Caching
  description: Add caching to the Dart proxy to improve performance.
  steps:
    - action: modify_dart_code
      file: bin/dart_proxy.dart
      changes:
        - type: add_caching_logic # Implement caching using a suitable Dart caching library

- name: Automatic Proxy Startup
  description: Modify the MCP server to automatically start the Dart proxy.
  steps:
    - action: modify_typescript_code
      file: src/index.ts
      changes:
        - type: add_startup_logic # Use child_process.spawn to start the Dart proxy

- name: Configuration
  description: Allow users to configure the Dart proxy port and other settings.
  steps:
    - action: modify_typescript_code
      file: src/index.ts
      changes:
        - type: add_configuration_options # Add options to your MCP server configuration

- name: Security
  description: Add authentication to the Dart proxy server if needed.
  steps:
    - action: modify_dart_code
      file: bin/dart_proxy.dart
      changes:
        - type: add_authentication # Implement authentication using shelf middleware

# Notes:

# - Replace placeholders (e.g., file paths, class names) with your actual values.
# - This YAML file is a structured plan, not executable code.  You'll need to
#   manually implement the steps described.
# - The 'expected_output' fields are for guidance and may vary slightly
#   depending on your environment.
# - Consider using a version control system (like Git) to track your changes.
# - Thoroughly test each step before proceeding to the next.
# - This plan assumes basic familiarity with Dart, TypeScript, and Flutter development.