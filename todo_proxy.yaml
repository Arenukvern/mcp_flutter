# todo_proxy.yaml: Plan for Setting Up and Integrating the Dart Proxy Server

# Overview:
# This document outlines the steps to create, configure, and integrate a Dart proxy server
# for interacting with the Flutter VM Service, specifically for retrieving widget tree
# information in a robust and maintainable way.  This plan uses the 'ext.flutter.inspector'
# service extension methods for programmatic access, ensuring compatibility and proper
# memory management.  

# Phase 1: Dart Proxy Server Setup ✅

- name: Update Dependencies ✅
  description: Update necessary packages to pubspec.yaml.
  steps:
    - action: edit_file ✅
      file: pubspec.yaml
      changes:
        - type: add_dependency
          dependency: vm_service
          version: ^13.0.0 # Use latest compatible version
        - type: add_dependency
          dependency: shelf
          version: ^1.4.1 # Or shelf_router
        - type: add_dependency
          dependency: shelf_web_socket
          version: ^1.0.4
        - type: add_dependency
          dependency: web_socket_channel
          version: ^2.4.0
        - type: add_dependency
          dependency: json_annotation
          version: ^4.8.1
        - type: add_dependency
          dependency: logging
          version: ^1.2.0
    - command: dart pub get ✅
      cwd: ./dart_proxy
      expected_output: "Resolving dependencies..."

- name: Implement Proxy Logic ✅
  description: Create the main Dart file and implement the proxy logic.
  steps:
    - action: create_file ✅
      file: bin/dart_proxy.dart
      content: |
        import 'dart:async';
        import 'dart:convert';
        import 'dart:io';

        import 'package:vm_service/vm_service.dart' as vm_service;
        import 'package:vm_service/vm_service_io.dart';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as shelf_io;
        import 'package:shelf_web_socket/shelf_web_socket.dart';
        import 'package:web_socket_channel/web_socket_channel.dart';

        void main() async {
          final handler = webSocketHandler((WebSocketChannel webSocket) {
            webSocket.stream.listen((message) async {
              try {
                final request = jsonDecode(message);
                final command = request['command'];
                final port = request['port'] ?? 8181;

                vm_service.VmService? vmService;
                try {
                  vmService = await vmServiceConnectUri(
                    'ws://localhost:$port/ws',
                    log: StdOutLogger(), // Optional logging
                  );
                } catch (e) {
                  webSocket.sink.add(jsonEncode({'error': 'Failed to connect to VM Service: $e'}));
                  return;
                }

                if (vmService == null) {
                  webSocket.sink.add(jsonEncode({'error': 'Not connected to VM Service.'}));
                  return;
                }

                switch (command) {
                  case 'getWidgetTree':
                    final includeProperties = request['includeProperties'] ?? false;
                    final subtreeDepth = request['subtreeDepth'] ?? 1000; // Default depth
                    final widgetTree = await getWidgetTree(
                      vmService,
                      includeProperties: includeProperties,
                      subtreeDepth: subtreeDepth,
                    );
                    webSocket.sink.add(jsonEncode({'result': widgetTree}));
                    break;
                  // Add other commands here (e.g., getProperties, setSelection, etc.)
                  default:
                    webSocket.sink.add(jsonEncode({'error': 'Unknown command: $command'}));
                }
              } catch (e) {
                webSocket.sink.add(jsonEncode({'error': 'Error: $e'}));
              }
            });
          });

          final server = await shelf_io.serve(handler, 'localhost', 8888);
          print('Proxy server listening on port ${server.port}');
        }

        Future<Map<String, dynamic>> getWidgetTree(
          vm_service.VmService vmService, {
          bool includeProperties = false,
          int subtreeDepth = 1000,
        }) async {
          final vm = vmService;
          final isolates = await vm.isolates();
          if (isolates.isolates == null || isolates.isolates!.isEmpty) {
            throw Exception('No isolates found.');
          }
          final isolate = isolates.isolates!.first; // Assuming the first isolate is the main one
          final isolateId = isolate.id!;

          // Check if the widget tree is ready.
          final isWidgetTreeReady = await vmService.callServiceExtension(
            'ext.flutter.inspector.isWidgetTreeReady',
            isolateId: isolateId,
          );

          if (isWidgetTreeReady.json!['result'] != true) {
              throw Exception("Widget tree is not ready");
          }


          // Get the root widget summary tree.
          final summaryTree = await vmService.callServiceExtension(
            'ext.flutter.inspector.getRootWidgetSummaryTree',
            isolateId: isolateId,
          );

          // Convert to a more usable format and recursively fetch details.
          return _processWidgetTree(vmService, isolateId, summaryTree.json!, subtreeDepth, includeProperties, {});
        }

        Future<Map<String, dynamic>> _processWidgetTree(
          vm_service.VmService vmService,
          String isolateId,
          Map<String, dynamic> widgetData,
          int subtreeDepth,
          bool includeProperties,
            Map<String, dynamic> idToJson,
        ) async {
          final String? id = widgetData['id'];
          final String? creationLocation = widgetData['creationLocation'];

          // Fetch properties if requested.
          Map<String, dynamic>? properties;
          if (includeProperties && id != null) {
              idToJson[id] = widgetData;
            try {
              final propertiesResponse = await vmService.callServiceExtension(
                'ext.flutter.inspector.getProperties',
                isolateId: isolateId,
                args: {'objectId': id},
              );
              properties = propertiesResponse.json!;
            } catch (e) {
              print('Error fetching properties for $id: $e');
              properties = {'error': 'Failed to fetch properties'};
            }
          }

          final result = {
            'description': widgetData['description'],
            'type': widgetData['type'],
            'properties': properties, // Include properties
            'creationLocation': creationLocation,
            'children': <Map<String, dynamic>>[],
          };

          if (id != null && subtreeDepth > 0) {
            try {
              // Get detailed children.
              final childrenResponse = await vmService.callServiceExtension(
                'ext.flutter.inspector.getChildrenDetailsSubtree',
                isolateId: isolateId,
                args: {'objectId': id, 'subtreeDepth': subtreeDepth -1},
              );

              final children = childrenResponse.json!['children'] as List<dynamic>?;
              if (children != null) {
                for (final child in children) {
                  result['children'].add(await _processWidgetTree(
                    vmService,
                    isolateId,
                    child,
                    subtreeDepth - 1,
                    includeProperties,
                      idToJson
                  ));
                }
              }
            } catch (e) {
              print('Error fetching children for $id: $e');
              result['children'].add({'error': 'Failed to fetch children'});
            } finally {
                // Always dispose of the ID to prevent memory leaks.
                await vmService.callServiceExtension('ext.flutter.inspector.disposeId',
                    isolateId: isolateId, args: {'id': id});
            }
          }

          return result;
        }

- name: Run Dart Proxy
  description: Start the Dart proxy server.
  steps:
    - command: dart run bin/dart_proxy.dart
      cwd: ./dart_proxy
      expected_output: "Proxy server listening on port 8888"

# Phase 2: MCP Server Modifications (TypeScript) [COMPLETED]

- name: Update MCP Server Code [COMPLETED]
  description: Modify the MCP server to communicate with the Dart proxy.
  steps:
    - action: edit_file [COMPLETED]
      file: src/index.ts # Replace with your actual file path
      changes:
        - type: add_import [COMPLETED]
          import: WebSocket
          from: ws
        - type: add_property [COMPLETED]
          class_name: FlutterInspectorServer  # Replace with your class name
          property: dartProxyWs
          type: WebSocket | null
          initial_value: null
        - type: add_property [COMPLETED]
          class_name: FlutterInspectorServer
          property: proxyPort
          type: number
          initial_value: 8888
        - type: add_property [COMPLETED]
          class_name: FlutterInspectorServer
          property: pendingProxyRequests
          type: 'Map<string, { resolve: Function; reject: Function }>'
          initial_value: 'new Map()'
        - type: add_method [COMPLETED]
          class_name: FlutterInspectorServer
          method_name: connectToDartProxy
          return_type: 'Promise<WebSocket>'
        - type: add_method [COMPLETED]
          class_name: FlutterInspectorServer
          method_name: sendDartProxyRequest
          return_type: 'Promise<any>'
        - type: modify_switch_case [COMPLETED]
          switch_variable: request.params.name
          case: get_widget_tree_proxy # Add or modify this case
        - type: add_tool [COMPLETED]
          tool_name: get_widget_tree_proxy
          description: "Gets the widget tree via the Dart proxy server."

# Phase 3: Testing and Verification

- name: Run Flutter App in Debug Mode
  description: Ensure the Flutter app is running in debug mode.
  steps:
    - command: flutter run --debug -d chrome # Or your preferred device
      cwd: ./your_flutter_app  # Replace with your Flutter app directory
      expected_output: "Debug service listening on ws://..."

- name: Test from MCP Server
  description: Use Cursor or another client to send requests to the MCP server.
  steps:
    - action: send_mcp_request
      tool: get_widget_tree_proxy
      arguments:
        port: 8181  # Or the port your Flutter app is using
        includeProperties: true # Optional
        subtreeDepth: 5 # Optional
      expected_output: "A JSON representation of the widget tree"

- name: Verify Output
  description: Check that the output is a structured JSON object representing the widget tree.
  steps:
    - action: verify_json_structure
      expected_structure:
        - description: string
        - type: string
        - properties: object | null
        - children: array

# Phase 4: Refinements and Extensions (Optional)

- name: Add More Commands
  description: Extend the Dart proxy to handle other inspector commands.
  steps:
    - action: modify_dart_code
      file: bin/dart_proxy.dart
      changes:
        - type: add_case
          switch_variable: command
          case: getProperties # Example: Add a case for getProperties
          content: |
            case 'getProperties':
              // ... Implement logic to fetch properties ...
              break;
    - action: modify_typescript_code
      file: src/index.ts
      changes:
        - type: add_tool # Add corresponding tool in MCP server
          tool_name: get_properties_proxy
          # ... tool definition ...
        - type: modify_switch_case
          switch_variable: request.params.name
          case: get_properties_proxy
          content: |
            case "get_properties_proxy": {
              // ... Call sendDartProxyRequest with appropriate arguments ...
            }

- name: Implement Caching
  description: Add caching to the Dart proxy to improve performance.
  steps:
    - action: modify_dart_code
      file: bin/dart_proxy.dart
      changes:
        - type: add_caching_logic # Implement caching using a suitable Dart caching library

- name: Automatic Proxy Startup
  description: Modify the MCP server to automatically start the Dart proxy.
  steps:
    - action: modify_typescript_code
      file: src/index.ts
      changes:
        - type: add_startup_logic # Use child_process.spawn to start the Dart proxy

- name: Configuration
  description: Allow users to configure the Dart proxy port and other settings.
  steps:
    - action: modify_typescript_code
      file: src/index.ts
      changes:
        - type: add_configuration_options # Add options to your MCP server configuration

- name: Security
  description: Add authentication to the Dart proxy server if needed.
  steps:
    - action: modify_dart_code
      file: bin/dart_proxy.dart
      changes:
        - type: add_authentication # Implement authentication using shelf middleware

# Notes:

# - Replace placeholders (e.g., file paths, class names) with your actual values.
# - This YAML file is a structured plan, not executable code.  You'll need to
#   manually implement the steps described.
# - The 'expected_output' fields are for guidance and may vary slightly
#   depending on your environment.
# - Consider using a version control system (like Git) to track your changes.
# - Thoroughly test each step before proceeding to the next.
# - This plan assumes basic familiarity with Dart, TypeScript, and Flutter development.