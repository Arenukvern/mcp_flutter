project_restructure:
  files_to_create:
    1. src/rpc/flutter_rpc.ts:
      - Contains all Flutter-specific RPC method definitions
      - Groups methods by category (inspector, debug, performance, etc)
      - Exports properly typed RPC constants
      - Includes documentation headers for each method group

    2. src/rpc/utilities_rpc.ts:
      - Contains utility methods and non-RPC tools
      - Includes:
        - get_active_ports
        - get_supported_protocols 
        - get_vm_info
        - get_extension_rpcs
        - port discovery helpers
        - connection validation utils

    3. src/handlers/tool_handlers.ts:
      - Contains handler implementations for:
        - ListToolsRequestSchema
        - CallToolRequestSchema
      - Separates Flutter RPC handlers from utility handlers
      - Uses dependency injection for RPC clients

    4. src/proxy/proxy_server.ts:
      - Handles all Dart proxy communication
      - Manages WebSocket connections
      - Implements retry logic
      - Handles message serialization/deserialization

  index_ts_refactor:
    - Becomes main entry point only
    - Responsibilities:
      - Server initialization
      - Dependency composition
      - Module wiring
      - Error handling
    - Imports from:
      - rpc/flutter_rpc
      - rpc/utilities_rpc  
      - handlers/tool_handlers
      - proxy/proxy_server

implementation_steps:
  1. Create directory structure:
    - mkdir -p src/{rpc,handlers,proxy}

  2. Split flutter_rpc:
    - Move enum rpc_prefix
    - Move flutter_rpc object structure
    - Add type definitions for all RPC methods
    - Export from src/rpc/flutter_rpc.ts

  3. Extract utilities_rpc:
    - Create new UtilitiesRPC class
    - Port utility methods from FlutterInspectorServer:
      - get_active_ports
      - verify_flutter_debug_mode
      - connection helpers
    - Add utility-specific types

  4. Implement tool_handlers:
    - Create BaseToolHandler abstract class
    - Implement FlutterToolHandler (extends Base)
    - Implement UtilityToolHandler (extends Base) 
    - Move setup_tool_handlers logic here
    - Use strategy pattern for different tool types

  5. proxy_server implementation:
    - Create DartProxyClient class
    - Move proxy-related methods from FlutterInspectorServer:
      - connect_to_dart_proxy
      - send_dart_proxy_request
      - pending_proxy_requests
    - Add connection pooling
    - Implement heartbeat mechanism

  6. Update FlutterInspectorServer:
    - Compose dependencies:
      - constructor(flutter_rpc, utilities_rpc, tool_handlers, proxy_client)
    - Remove migrated logic
    - Keep core server lifecycle management

testing_plan:
  validation_checklist:
    - [ ] All RPC methods available after split
    - [ ] Utility tools work without Flutter connection
    - [ ] Proxy communication remains functional
    - [ ] Type definitions match original behavior
    - [ ] Error handling preserved across modules
    - [ ] Logging context maintained
    - [ ] All CLI commands still functional

migration_strategy:
  phase1: Extract independent modules
  phase2: Update imports/references
  phase3: Verify core functionality
  phase4: Add test coverage
  phase5: Remove legacy code

documentation_updates:
  - Add ARCHITECTURE.md explaining new structure
  - Update README with new module map
  - Add JSDoc comments to all RPC methods
  - Create proxy_comms.md for Dart protocol